[
    {
        "name": "sum(1)(2)(3)()",
        "content": "function sum(a) { \n    sum.result = sum.result || 0; \n    if (a) { \n        sum.result = sum.result + a; \n        return sum; \n    } else { \n        result = sum.result; \n        sum.result = null; \n        return result; \n    } \n} \n \n// rescursive \nfunction sum(a) { \n    let result = a; \n    let helper = (a) => { \n        if (a) { \n            result += a \n            return helper; \n        } else { \n            return result; \n        } \n    }; \n    return helper; \n} \n \n \n// the below problem should pass \nconsole.log(sum(1)(2)(3)() === 6); \nconsole.log(sum(1)(2)(3)(4)() === 10); \n"
    },
    {
        "name": "Frequency_Counter",
        "content": "// write a 'same' funtion to compare 2 arrays when  each number in the second array is the squared value of the number in the first array.  \n// Order of number placement in between the both arrays does not matter as long as the all numbers in first array has got squared value in teh 2nd array \n \n// frequency counter is the pattern to map each array item as key value pair in a obj  \n// and compare the key and value with other object/array to reduce O(n^2) timrcomplexity  \n \nfunction same(a1, a2) { \n    // check length of both arrays and if not equal return false \n    if (a1.length !== a2.length) { \n        return false; \n    } \n \n    // convert 2nd array into object \n    const obj1 = {}; \n    for (let i of a2) { \n        obj1[i] = false; \n    } \n \n    // iterate thru 1st array and check the aquared value of each number is exist in the obj1 \n    for (let j of a1) { \n        if (obj1.hasOwnProperty(j ** 2)) { \n            obj1[j ** 2] = true; \n        } \n    } \n \n    // return false if any one or more number does not have value \n    return !Object.values(obj1).includes(false); \n} \n  \n// tests \nconsole.log(same([1, 2, 3, 2], [5, 4, 9, 1])); // === false \nconsole.log(same([1, 2, 3], [4, 1])); // === false \nconsole.log(same([1, 2, 3], [4, 9, 2])); // === false \nconsole.log(same([1, 2, 3], [4, 9, 1])); // === true \n \n \nfunction sameFrequency(int1, int2){ \n  // good luck. Add any arguments you deem necessary. \n  let a = int1.toString(); \n  let lookup =  {}; \n  for (let  i = 0; i < a.length; i++) { \n      lookup[a[i]] = ++lookup[a[i]] || 1; \n  } \n  for (let j of int2.toString()) { \n      if (lookup[j] && lookup[j] > 0) { \n          lookup[j] = lookup[j] - 1; \n      } else { \n          return false; \n      } \n  } \n  return true; \n} \nconsole.log('---------------------') \nconsole.log(sameFrequency(182, 281)) // true \nconsole.log(sameFrequency(34, 14)) // false \nconsole.log(sameFrequency(3589578, 5879385)) // true \nconsole.log(sameFrequency(22, 222)) // false"
    },
    {
        "name": "anagram",
        "content": "// write a function to compare 2 strings are of anagram or not \n// Anagram cinema and iceman are anagram words \n \n// easy solution with in-built JS methods .- O(n * log(n)) time complexity \nfunction anagram(str1, str2) { \n    return str1.split('').sort().join('') === str2.split('').sort().join(''); \n} \n \n// own solution with frenquecy counter pattern - O(n) time complexity \nfunction anagram(str1, str2) { \n     \n    // if strings length are not same, then output false \n    if (str1.length !== str2.length) { \n        return false; \n    } \n \n    // convert string into array \n    const arr1 = str1.split(''); \n    const arr2 = str2.split(''); \n \n    // modify string array into objects \n    // add char to obj with value 1 if char not exists in the onb or increment value by 1 \n    const strObj1 = {}, strObj2 = {}; \n    for (let i of arr1) { \n        strObj1[i] = ++strObj1[i] || 1;  \n    } \n    for (let j of arr2) { \n        strObj2[j] = ++strObj2[j] || 1;  \n    } \n \n    // compare both obj keys with its value and its existence \n    for (let k of Object.keys(strObj1)) { \n        if (!strObj2[k] || strObj2[k] !== strObj1[k]) { \n            return false; \n        } \n    } \n \n    // if everything goes well, output true \n    return true; \n} \n \n// more errificent solution with frenquecy counter pattern - O(n) time complexity \nfunction anagram(str1, str2) { \n     \n    // if strings length are not same, then output false \n    if (str1.length !== str2.length) { \n        return false; \n    } \n \n    // modify first string into object \n    const lookup = {}; \n    for (let i of str1) { \n        lookup[i] = ++lookup[i] || 1;  \n    } \n     \n    // iterate 2nd string char and check if exists in obj and if exists decrement by 1 \n    // if no key exists in obj for a char or key value is 0 then output false \n    for (let j of str2) { \n        if (!lookup[j] || lookup[j] <= 0) { \n            return false; \n        } else { \n            lookup[j] = lookup[j] - 1; \n        } \n    } \n \n    // if everything goes well, output true \n    return true; \n} \n \nconsole.log(anagram('cinema', 'iceman')); // true \nconsole.log(anagram('cinema', ''));  // false \nconsole.log(anagram('xxx', 'xx'));  // false \nconsole.log(anagram('abc', 'cba'));  // true"
    },
    {
        "name": "Multiple_Pointers",
        "content": "// write a function called sumZero which accepts a sorted array of intergers, \n// the fn should find the 1st pair where the sum is 0. \n \n// multiple pointer pattern works only for sorted array in this situation \nfunction sumZero(arr) { \n     \n    // create 2 pointers 1 for first  anf 1 for last \n    let left = 0; \n    let right = arr.length - 1; \n \n    // iterate the array and compare as long as left is less than riget \n    while (left < right) { \n        const sum = arr[left] + arr[right]; \n \n        // if sum is 0 then return the pair \n        if (sum === 0) { \n            return [arr[left], arr[right]]; \n        } \n \n        // if sum is less than 0 increment index value in left pointer else decrease index value in right pointer \n        if (sum < 0) { \n            left = left + 1; \n        } else { \n            right = right - 1; \n        } \n    } \n \n    // if none sums up 0 then return empty array \n    return []; \n}  \n \nconsole.log(sumZero([-2,-1,0,1,2])); // [-2, 2] \nconsole.log(sumZero([-10, -9, -3, -2,-1,0,1,3, 99, 100, 199])); // [-3, 3] \nconsole.log(sumZero([0,1,3, 99, 100, 199])); // []"
    },
    {
        "name": "count_unique_values_in_arr",
        "content": "// implement a fn which returns the count of unique values in a sorted array \n \n \n// frequency pattern \nfunction uniqueValueInArray(arr) { \n    // create a map for valie with no of occurences \n    const lookup = {}; \n    for (let i of arr) { \n        lookup[i] = ++lookup[i] || 1; \n    } \n    return Object.keys(lookup).length; \n} \n \n// 2 pointer pattern \nfunction uniqueValueInArray(arr) { \n \n    // null check \n    if (!arr.length) return 0; \n \n    // create a initial pointer for starting value \n    let i = 0; \n \n    // iterate the array to compare the pointer value with each value in the array \n    for (let j = 0; j < arr.length; j++) { \n \n        // when initial value does not match with value in the array \n        // increment pointer value by 1 and update the arr value with unmatched value consequetly \n        if (arr[i] !== arr[j]) { \n            i = i + 1; \n            arr[i] = arr[j]; \n        } \n    } \n \n    // pointer + 1 will be the count of unique values \n    return i + 1; \n} \n \n \nconsole.log(uniqueValueInArray([1, 1, 1, 1, 2, 2, 3, 4, 4, 5])); // 5 \nconsole.log(uniqueValueInArray([])); // 0"
    },
    {
        "name": "longestUniqueCharString",
        "content": "// wirte a function which gives the longest substring which contains unique characters in the given string \n// in string 'hellothere' longest unique char substring is 'lother' \n \n// using 2 pointer pattern \nfunction longestUniqueCharString(str) { \n    if (!str || !str.length) { \n        return ''; \n    } \n    let prevStringMap = { \n        [str[0]]: 1 \n    }; \n    let prevString = ''; \n    let substring = str[0]; \n    let initial = 0; \n    for (let i = 1; i <= str.length; i++) { \n        prevStringMap[str[i]] = ++prevStringMap[str[i]] || 1; \n        if (prevStringMap[str[i]] > 1) { \n            initial = initial + 1; \n            if (prevString.length < substring.length) { \n                prevString = substring \n                prevStringMap = {}; \n            } \n            substring = str[i]; \n        } else { \n            initial = initial + 1; \n            substring = str[i] ? substring + str[i] : substring; \n        } \n    } \n    return prevString.length > substring.length ? prevString : substring \n \n} \n \nconsole.log(longestUniqueCharString('hellothere')); \n// 'lother' \nconsole.log(longestUniqueCharString('apple')); \n// 'ple' \nconsole.log(longestUniqueCharString('')); \n// '' \nconsole.log(longestUniqueCharString('sliding_window_pattern')); \n// ndow_pat \n"
    },
    {
        "name": "max_sub_array_sum",
        "content": "// write a function to find out the maximum sum of given number of consequtive values in the array \n// array: [1,2,5,2,8,1,5] and the consequtive number for summing up values is 2 then answer is 10 (2 + 8) \n \n// O(n^2) time complexity nested loops \nfunction maxSubArraySum(arr, number) { \n    if (arr.length < number) { \n        return null; \n    } \n    let maxSum = 0; \n    for (let j = 0; j < arr.length; j++) { \n        let tempSum = 0; \n        for (let i = 0; i < number; i++) { \n            tempSum = j + i < arr.length ? tempSum + arr[j + i] : tempSum; \n            if (i === number - 1) { \n                maxSum = Math.max(maxSum, tempSum); \n            } \n        } \n    } \n    return maxSum; \n} \n \n// sliding window pattern => O(n) time complexity \nfunction maxSubArraySum(arr, number) { \n    // check given number is greater than array length. if yes, return null \n    if (arr.length < number) { \n        return null; \n    } \n \n    let tempSum = 0; \n \n    // sum first 'number' of values in array \n    for (let j = 0; j < number; j++) { \n        tempSum = tempSum + arr[j]; \n    } \n \n    // maxSum will be first sum from previous loop \n    let maxSum = tempSum; \n \n    // loop remaining numbers and compare maxSum and tempSum \n    for (let i = number; i < arr.length; i++) { \n        // difference of adding the next value and minusing the previous value  \n        // will be the sum of given number of values in array at any point of time \n        tempSum = tempSum + arr[i] - arr[i - number]; \n        maxSum = Math.max(tempSum, maxSum); \n    } \n    return maxSum; \n} \n \nconsole.log(maxSubArraySum([1, 2, 5, 2, 8, 1, 5], 2)); \n// 10 \nconsole.log(maxSubArraySum([1, 2, 5, 2, 8, 1, 5], 4)); \n// 17 \nconsole.log(maxSubArraySum([4, 2, 1, 6], 1)); \n// 6 \nconsole.log(maxSubArraySum([4, 2, 1, 6, 2], 4)); \n// 13 \nconsole.log(maxSubArraySum([], 4)); \n// null \n"
    },
    {
        "name": "binary_search",
        "content": "// write a function to return the index of the given value in an array if found. else return -1 \n// print the iterations count to find the index \n \nlet iterations = 0; \n// normal linear search solution O(n) time complexity \nfunction indexOf(arr, value) { \n    for (let i = 0; i < arr.length; i++) { \n        iterations++; \n        if (value === arr[i]) { \n            return i; \n        } \n    } \n    return -1; \n} \n \n// 1, 7, 9, 10, 18 \n// min 0 => 1  \n// max 4 => 18 \n// mid 4 /2 => 2 => 9 \n// arr[mid] (9) === 18 => false \n// arr[mid] (9) > 18 => true \n// subarray  \n// min => 3 => 10 \n// mid => 3 => 10 \n \n// else secnario in case the number is below the mid point 7 \n// max => 1 => 7 \n// mid => 0 \n \nfunction binarySearch(arr, val) { \n    let min = 0; \n    let max = arr.length - 1; \n    let mid = Math.floor((min + max) / 2); \n    while (arr[mid] !== val && min < max) { \n        if (val < arr[mid]) { \n            max = mid - 1; \n        } else { \n            min = mid + 1; \n        } \n        mid = Math.floor((min + max) / 2); \n    } \n    return arr[mid] === val ? mid : -1; \n}  \n \n \nconsole.log(binarySearch([1,2,3,4,5],2)); // 1 \nconsole.log(binarySearch([1,2,3,4,5],3)); // 2 \nconsole.log(binarySearch([1,2,3,4,5],5)); // 4 \nconsole.log(binarySearch([1,2,3,4,5],6)); // -1 \nconsole.log(binarySearch([5, 6, 10, 13, 14, 18, 30, 34, 35, 37, 40, 44, 64, 79, 84, 86, 95, 96, 98, 99], 10)); // 2 \nconsole.log(binarySearch([5, 6, 10, 13, 14, 18, 30, 34, 35, 37, 40, 44, 64, 79, 84, 86, 95, 96, 98, 99], 95)); // 16 \nconsole.log(binarySearch([5, 6, 10, 13, 14, 18, 30, 34, 35, 37, 40, 44, 64, 79, 84, 86, 95, 96, 98, 99], 64)); // 12"
    },
    {
        "name": "areThereDuplicates",
        "content": "// Implement a function called, areThereDuplicates  \n// which accepts a variable number of arguments,  \n// and checks whether there are any duplicates among the arguments passed in.  \n// You can solve this using the frequency counter pattern OR the multiple pointers pattern. \n \n// frequency counter pattern O(n) time complexity \nfunction areThereDuplicates() { \n    let a = [...arguments]; \n    let lookup = {}; \n    for (let i = 0; i < a.length; i++) { \n        lookup[a[i]] = ++lookup[a[i]] || 1; \n        if (lookup[a[i]] > 1) { \n            return true; \n        } \n    } \n    return false; \n} \n \n// multiple pointers pattern O(log(n)) time complexity \nfunction areThereDuplicates() { \n    let a = [...arguments].sort();  // o(n* log(n)) \n    let left = 0; \n    for (let i = 1; i < a.length; i++) { \n        if (a[i] === a[left]) { \n            return true; \n        } else { \n            left++; \n        } \n    } \n \n    return false; \n} \n \nconsole.log(areThereDuplicates(1, 2, 3)); // false \nconsole.log(areThereDuplicates(1, 2, 2)); // true \nconsole.log(areThereDuplicates('b', 'a', 'c', 'a')); // true \n \n// a b c a \n// "
    },
    {
        "name": "averagePair",
        "content": "// Write a function called averagePair.  \n// Given a sorted array of integers and a target average,  \n// determine if there is a pair of values in the array  \n// where the average of the pair equals the target average.  \n// There may be more than one pair that matches the average target. \n \n// Bonus Constraints: \n// Time: O(N) \n// Space: O(1) \n \n \n// O (n) \nfunction averagePair(arr, avg) { \n    if (!arr.length) { \n       return false;  \n    } \n    for (let i = 0; i < arr.length - 1; i++) { \n        if (arr[i] + arr[i+1] === avg * 2) { \n            return true; \n        } \n    } \n    return false; \n} \n \n// multiple pointer \nfunction averagePair(arr, num){ \n  let start = 0 \n  let end = arr.length-1; \n  while(start < end){ \n    let avg = (arr[start]+arr[end]) / 2  \n    if(avg === num) return true; \n    else if(avg < num) start++ \n    else end-- \n  } \n  return false; \n} \n \n//Sample Input: \nconsole.log(averagePair([1,2,3], 2.5)); // true \nconsole.log(averagePair([1,3,3,5,6,7,10,12,19], 8)); // true \nconsole.log(averagePair([-1,0,3,4,5,6], 4.1)); // false \nconsole.log(averagePair([], 4)); // false \n \n// 1, 2, 3 \n \n// 2 => 2 + 3 / 2 = 2.5 \n \n"
    },
    {
        "name": "isSubSequence",
        "content": "// Multiple Pointers - isSubsequence \n// Write a function called isSubsequence which takes in two strings  \n// and checks whether the characters in the first string  \n// form a subsequence of the characters in the second string.  \n// In other words, the function should check whether the characters  \n// in the first string appear somewhere in the second string, \n// without their order changing. \n// solution MUST have AT LEAST the following complexities: \n// Time Complexity - O(N + M) \n// Space Complexity - O(1) \n \n \n// brute force  \nfunction isSubsequence(s1, s2) { \n    let result = ''; \n \n    let big = '', small = ''; \n    if (s1.length > s2.length) { \n        big = s1.toLowerCase().trim(); \n        small = s2.toLowerCase().trim(); \n    } else { \n        big = s2.toLowerCase().trim(); \n        small = s1.toLowerCase().trim(); \n    } \n    let lookup = {}; \n    for (let a of small) { \n        lookup[a] = ++lookup[a] || 1;  \n    } \n    for (let i = 0; i < big.length; i++) { \n        for (let j = 0; j < small.length; j++) { \n            if (small[j] === big[i] && lookup[small[j]] !== 0) { \n                result = result + small[j]; \n                lookup[small[j]]--; \n                continue; \n            } \n        } \n    } \n    console.log(result); \n    return result === small; \n} \n \n//  - Iterative \nfunction isSubsequence(str1, str2) { \n  var i = 0; \n  var j = 0; \n  if (!str1) return true; \n  while (j < str2.length) { \n    if (str2[j] === str1[i]) i++; \n    if (i === str1.length) return true; \n    j++; \n  } \n  return false; \n} \n \n \n// Examples: \nconsole.log(isSubsequence('sing', 'stingg')); // true \nconsole.log(isSubsequence('hello', 'hello world')); // true \nconsole.log(isSubsequence('abc', 'abracadabra')); // true \nconsole.log(isSubsequence('abc', 'acb')); // false (order matters) \nconsole.log(isSubsequence('yo', 'yo')) // true \nconsole.log(isSubsequence('aaa Madam,', 'I'm Adam')) // false \nconsole.log(isSubsequence('Thqckbrwnfxjmpdvrthlzydg', 'The quick brown fox jumped over the lazy dog')) // true \n \n \n \n \n"
    },
    {
        "name": "twoSum",
        "content": "// Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. \n// You may assume that each input would have exactly one solution, and you may not use the same element twice. \n// You can return the answer in any order. \n \n// brute force \nfunction twoSum(nums, target) { \n   let res; \n   for (let i = 0; i < nums.length; i++) { \n        for (let j = 0; j < nums.length; j++) { \n            if (i !== j && nums[i] + nums[j] === target) { \n                res = [j, i]; \n                break; \n            } \n        } \n    } \n    return res; \n}; \n \n// freq counter \nfunction twoSum(nums, target) { \n    let lookup = {}; \n    for (let i = 0; i < nums.length; i++) { \n       lookup[nums[i]] = i;  \n    } \n    nums = nums.sort((x, y) => x - y); \n    let min = 0, max = nums.length -1; \n    while (min < max) { \n        let sum = nums[min] + nums[max]; \n        if (sum === target) { \n            return [lookup[nums[min]], lookup[nums[max]]]; \n        } else if (sum > target) { \n            max--; \n        } else { \n            min++ \n        } \n    } \n} \n \n \n/** \n * @param {number[]} nums \n * @param {number} target \n * @return {number[]} \n */ \n let iterations = 0; \nfunction twoSum(nums, target, memo = {}) { \n    iterations++; \n    if (target in memo) return memo[target]; \n    if (target === 0) { \n        memo[target] = []; \n        return memo[target]; \n    } \n    if (target < 0) { \n        memo[target] = null; \n        return memo[target] \n    } \n    for (let i = 0; i < nums.length; i++) { \n        const newNums = [...nums]; \n        let result = [...newNums.splice(i, 1)]; \n        const res = twoSum(newNums, target - nums[i]); \n        if(res !== null) { \n            memo[target] = [...result, ...res]; \n            return memo[target]; \n        } \n    } \n    memo[target] = null \n    return memo[target]; \n}; \n \n// console.log(twoSum([3,2,4], 6)); // [1,2] \n// console.log(twoSum([2,7,11,15], 9)); // [2,7] \n// console.log(twoSum([2,4,11,3], 6)); // [2, 4] \n// console.log(twoSum([3,3], 6)); // [3, 3] \n// console.log(twoSum([3,4], 6)); // null \nconsole.log(twoSum([1,2,3], 500)); \nconsole.log('iterations', iterations);"
    },
    {
        "name": "recursive",
        "content": "function power(base, exp) { \n    if (exp === 0) { \n        return 1; \n    } \n    return base * power(base, --exp) \n} \n \nconsole.log(power(2, 0)); // 1 \nconsole.log(power(2, 2)); // 4 \nconsole.log(power(2, 4)); // 16 \n \n \nfunction factorial(x){ \n   if (x < 0 ) return 0; \n   if (x <= 1 ) return 1; \n   return x * factorial(x-1); \n} \n \nconsole.log(factorial(3));  // 6 \n"
    },
    {
        "name": "string_reverse",
        "content": "function reverse(s){ \n  let rs = ''; \n  const helper = (m) => { \n     if (!m.length) { \n       return; \n     } \n     rs += m.pop(); \n     helper(m); \n  } \n  helper(Array.from(s)); \n  return rs; \n} \n \nconsole.log(reverse('awesome') === 'emosewa'); // true \nconsole.log(reverse('rithmschool') === 'loohcsmhtir'); // true"
    },
    {
        "name": "isPalindrome",
        "content": " \nfunction isPalindrome(s){ \n    return s === s.split('').reverse().join(''); \n} \n \n \nconsole.log(isPalindrome('awesome')); // false \nconsole.log(isPalindrome('foobar')); // false \nconsole.log(isPalindrome('tacocat')); // true \nconsole.log(isPalindrome('amanaplanacanalpanama')); // true \nconsole.log(isPalindrome('amanaplanacanalpandemonium')); // false \n"
    },
    {
        "name": "recursive with callback",
        "content": "// Write a recursive function called someRecursive which accepts an array and a callback.  \n// The function returns true if a single value in the array returns true when passed to the callback.  \n// Otherwise it returns false. \n \n \n// normal \nfunction someRecursive(arr, cb){ \n  for (let i of arr) { \n      if (cb(i)) { \n          return true; \n      } \n  } \n  return false; \n} \n \n \n// recursive \nfunction someRecursive(arr, cb){ \n    if (!arr.length) { \n        return false; \n    } \n    if (cb(arr.pop())) { \n        return true; \n    } \n    return someRecursive(arr, cb); \n} \n \n \n// SAMPLE INPUT / OUTPUT \nconst isOdd = val => val % 2 !== 0; \n \nconsole.log(someRecursive([1,2,3,4], isOdd)); // true \nconsole.log(someRecursive([4,6,8,9], isOdd)); // true \nconsole.log(someRecursive([4,6,8], isOdd)); // false \nconsole.log(someRecursive([4,6,8], val => val > 10)); // false"
    },
    {
        "name": "flatten",
        "content": "function flatten(arr) { \n    let res = []; \n    for (let i of arr) { \n        if (Array.isArray(i)) { \n            res = [...res, ...flatten(i)]; \n        } else { \n           res.push(i);  \n        } \n    } \n    return res; \n} \n \nconsole.log(flatten([1, 2, 3, [4, 5] ])); // [1, 2, 3, 4, 5] \nconsole.log(flatten([1, [2, [3, 4], [[5]]]])); // [1, 2, 3, 4, 5] \nconsole.log(flatten([[1],[2],[3]])); // [1,2,3] \nconsole.log(flatten([[[[1], [[[2]]], [[[[[[[3]]]]]]]]]])); // [1,2,3] \n           "
    },
    {
        "name": "capitalizeFirst",
        "content": "function capitalizeFirst (arr) { \n  let res = []; \n  if (!arr.length) { \n      return res.reverse(); \n  } \n  let l = arr.shift(); \n  res.push(l.charAt(0).toUpperCase() + l.slice(1)); \n  return [...res, ...capitalizeFirst(arr)]; \n} \n \ncapitalizeFirst(['car','taco','banana']); // ['Car','Taco','Banana']"
    },
    {
        "name": "nestedEvenSum",
        "content": "function nestedEvenSum (obj) { \n  let result = 0; \n  for (let key in obj) { \n       if (typeof obj[key] === 'object') { \n           result += nestedEvenSum(obj[key]); \n      } else if (typeof obj[key] === 'number' && obj[key] % 2 === 0) { \n           result += obj[key]; \n      } \n  } \n  return result; \n} \n \n \nvar obj1 = { \n  outer: 2, \n  obj: { \n    inner: 2, \n    otherObj: { \n      superInner: 2, \n      notANumber: true, \n      alsoNotANumber: 'yup' \n    } \n  } \n} \n \nvar obj2 = { \n  a: 2, \n  b: {b: 2, bb: {b: 3, bb: {b: 2}}}, \n  c: {c: {c: 2}, cc: 'ball', ccc: 5}, \n  d: 1, \n  e: {e: {e: 2}, ee: 'car'} \n}; \n \nconsole.log(nestedEvenSum(obj1)); // 6 \nconsole.log(nestedEvenSum(obj2)); // 10"
    },
    {
        "name": "capitalizeWords",
        "content": "function capitalizedWords(arr) { \n    let result = []; \n    let helper = (inner) => { \n        if (inner.length) { \n            result.push(inner.shift().toUpperCase()); \n            helper(inner); \n        } \n    } \n    helper(arr); \n    return result; \n} \n \nlet words = ['i', 'am', 'learning', 'recursion']; \ncapitalizedWords(words); // ['I', 'AM', 'LEARNING', 'RECURSION'] \n"
    },
    {
        "name": "stringifyNumbers",
        "content": "function stringifyNumbers(obj) { \n    let newObj = {}; \n    for (let key in obj) { \n        if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) { \n            newObj[key] = stringifyNumbers(obj[key]) \n        } else if (typeof obj[key] === 'number') { \n            newObj[key] = obj[key].toString(); \n        } else { \n            newObj[key] = obj[key]; \n        } \n    } \n    return newObj; \n} \n \nlet input = { \n    num: 1, \n    test: [], \n    data: { \n        val: 4, \n        info: { \n            isRight: true, \n            random: 66 \n        } \n    } \n} \n \nstringifyNumbers(input); \n \n/* \n \noutput = \n{ \n    num: '1', \n    test: [], \n    data: { \n        val: '4', \n        info: { \n            isRight: true, \n            random: '66' \n        } \n    } \n} \n*/"
    },
    {
        "name": "collectStrings",
        "content": "function collectStrings(input) { \n    let result = []; \n    for (let key in input) { \n        if (typeof input[key] === 'object' && !Array.isArray(input[key])) { \n            result = [...result, ...collectStrings(input[key])] \n        } else if (typeof input[key] === 'string') { \n            result.push(input[key]); \n        } \n    } \n    return result; \n} \n \nconst obj = { \n    stuff: 'foo', \n    data: { \n        val: { \n            thing: { \n                info: 'bar', \n                moreInfo: { \n                    evenMoreInfo: { \n                        weMadeIt: 'baz' \n                    } \n                } \n            } \n        } \n    } \n} \ncollectStrings(obj) // ['foo', 'bar', 'baz'])"
    },
    {
        "name": "searchString",
        "content": "// binary search and return the index of the string on the array or -1 \nfunction searchString(arr, str) { \n    let first = 0; \n    let last = arr.length -1; \n    let mid = Math.floor(last / 2); \n    while (arr[mid] !== str && first < last) { \n        if (str.charCodeAt(0) > arr[mid].charCodeAt(0)) { \n            first = mid + 1; \n        } else { \n            last = mid - 1; \n        } \n         mid = Math.floor((first + last) / 2); \n    } \n    return arr[mid] !== str ? -1 : mid; \n} \n \nconst states = ['Andaman and Nicobar (UT)', 'Andhra Pradesh', 'Arunachal Pradesh', 'Assam', 'Bihar', 'Chandigarh (UT)', 'Chhattisgarh', 'Dadra and Nagar Haveli (UT)', 'Daman and Diu (UT)', 'Delhi', 'Goa', 'Gujarat', 'Haryana', 'Himachal Pradesh', 'Jammu and Kashmir', 'Jharkhand', 'Karnataka', 'Kerala', 'Lakshadweep (UT)', 'Madhya Pradesh', 'Maharashtra', 'Manipur', 'Meghalaya', 'Mizoram', 'Nagaland', 'Orissa', 'Puducherry (UT)', 'Punjab', 'Rajasthan', 'Sikkim', 'Tamil Nadu', 'Telangana', 'Tripura', 'Uttar Pradesh', 'Uttarakhand', 'West Bengal'] \nconsole.log(searchString(states, 'Bihar') === states.indexOf('Bihar')); // true \nconsole.log(searchString(states, 'Bihar1') === states.indexOf('Bihar1')); // -1 \nconsole.log(searchString(states, 'Andaman and Nicobar (UT)') === states.indexOf('Andaman and Nicobar (UT)')); // true \nconsole.log(searchString(states, 'West Bengal') === states.indexOf('West Bengal')); // true \nconsole.log(searchString(states, states[states.length / 2 -1]) === states.indexOf(states[states.length / 2 -1])); // true \n"
    },
    {
        "name": "countSubstring",
        "content": " \n// naive string search \nfunction countSubString(str, sub) { \n   let subLength = sub.length; \n   let count = 0; \n   for (let i = 0; i < str.length - subLength + 1; i++) { \n      let temp = str[i]; \n      for (let j = i+1; j < subLength+i+1; j++) { \n           temp += str[j]; \n           if (temp.length === subLength) { \n                console.log(temp); \n                count = temp === sub ? count+1 : count; \n           } \n      } \n   } \n   return count; \n} \n \n \nconsole.log(countSubString('lori loled', 'lol')); // 2"
    }
]